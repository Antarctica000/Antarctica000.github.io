<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-big-counter.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"antarctica.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="javaSE基础学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Antarctica">
<meta property="og:url" content="https://antarctica.github.io/2024/05/26/JavaSE/index.html">
<meta property="og:site_name" content="Antarctica">
<meta property="og:description" content="javaSE基础学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/%E5%90%B4%E4%BA%A6%E6%B6%B5/AppData/Roaming/Typora/typora-user-images/image-20240327121024092.png">
<meta property="og:image" content="c:/Users/%E5%90%B4%E4%BA%A6%E6%B6%B5/AppData/Roaming/Typora/typora-user-images/image-20240327121238273.png">
<meta property="og:image" content="c:/Users/%E5%90%B4%E4%BA%A6%E6%B6%B5/AppData/Roaming/Typora/typora-user-images/image-20240329091443572.png">
<meta property="og:image" content="c:/Users/%E5%90%B4%E4%BA%A6%E6%B6%B5/AppData/Roaming/Typora/typora-user-images/image-20240401123231589.png">
<meta property="article:published_time" content="2024-05-26T07:25:59.842Z">
<meta property="article:modified_time" content="2024-05-26T07:39:45.735Z">
<meta property="article:author" content="Antarctica">
<meta property="article:tag" content="Antarctica,Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/%E5%90%B4%E4%BA%A6%E6%B6%B5/AppData/Roaming/Typora/typora-user-images/image-20240327121024092.png">


<link rel="canonical" href="https://antarctica.github.io/2024/05/26/JavaSE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://antarctica.github.io/2024/05/26/JavaSE/","path":"2024/05/26/JavaSE/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Antarctica</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Antarctica</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Antarctica Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">第一阶段 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.</span> <span class="nav-text">1. 变量与运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%AF%BE%E5%A0%82%E7%BB%83%E4%B9%A0"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 转义字符课堂练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E2%80%9C-%E2%80%9D%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2  “+”号的使用（字符串拼接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E6%AF%94%E8%BE%83%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 浮点数运算比较的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-char%E4%B8%8Ebyte"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 char与byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 字符串与基本数据类型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.7 进制转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81%EF%BC%88%E7%BB%93%E5%90%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.8 原码 反码 补码（结合位运算符）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">2. 控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 switch语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-for%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2  for语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E7%BB%84-%E6%8E%92%E5%BA%8F-%E6%9F%A5%E6%89%BE"><span class="nav-number">1.3.</span> <span class="nav-text">3. 数组 排序 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 数组扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2  二维数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.</span> <span class="nav-text">4. 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88Constructor%EF%BC%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 构造器（Constructor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%8C%85"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.6.</span> <span class="nav-text">4.6 封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.7.</span> <span class="nav-text">4.7 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E5%A4%9A%E6%80%81"><span class="nav-number">1.4.8.</span> <span class="nav-text">4.8 多态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">第二阶段 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">1. 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 类变量与类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9A"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 代码块：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.4 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.5 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%B1%80%E9%83%A8%E4%BD%8D%E7%BD%AE%E4%B8%8A%EF%BC%8C%E6%9C%89%E7%B1%BB%E5%90%8D%EF%BC%89"><span class="nav-number">2.1.5.0.1.</span> <span class="nav-text">1.5.1 局部内部类（外部类的局部位置上，有类名）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BD%8D%E7%BD%AE%E4%B8%8A%EF%BC%8C%E6%97%A0%E7%B1%BB%E5%90%8D%EF%BC%89"><span class="nav-number">2.1.5.0.2.</span> <span class="nav-text">1.5.2 匿名内部类（外部类的成员位置上，无类名）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BD%8D%E7%BD%AE%E4%B8%8A%EF%BC%8C%E6%97%A0static%EF%BC%89"><span class="nav-number">2.1.5.0.3.</span> <span class="nav-text">1.5.3 成员内部类（外部类的成员位置上，无static）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BD%8D%E7%BD%AE%E4%B8%8A%EF%BC%8C%E6%9C%89static%EF%BC%89"><span class="nav-number">2.1.5.0.4.</span> <span class="nav-text">1.5.4 静态内部类（外部类的成员位置上，有static）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.2.</span> <span class="nav-text">2. 枚举与注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%82%E5%B8%B8"><span class="nav-number">2.3.</span> <span class="nav-text">3. 异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">4. 常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1 包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-String"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2 String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-StringBuffer"><span class="nav-number">2.4.3.</span> <span class="nav-text">4.3 StringBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-StringBuilder"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.4 StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Math"><span class="nav-number">2.4.5.</span> <span class="nav-text">4.5 Math</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-Arrays"><span class="nav-number">2.4.6.</span> <span class="nav-text">4.6 Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-System%E7%B1%BB"><span class="nav-number">2.4.7.</span> <span class="nav-text">4.7 System类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-BigInteger-%E5%92%8C-BigDecimal"><span class="nav-number">2.4.8.</span> <span class="nav-text">4.8 BigInteger 和 BigDecimal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="nav-number">2.4.9.</span> <span class="nav-text">4.9 日期类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%9B%86%E5%90%88"><span class="nav-number">2.5.</span> <span class="nav-text">5. 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1 集合体系图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2 Collection接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-List%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.3.</span> <span class="nav-text">5.3 List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-ArrayList"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">5.3.1 ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-LinkedList"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">5.3.2 LinkedList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.4.</span> <span class="nav-text">5.4 Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-HashSet"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">5.4.1 HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-LinkedHashSet"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">5.4.2 LinkedHashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-TreeSet"><span class="nav-number">2.5.4.3.</span> <span class="nav-text">5.4.3 TreeSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.5.</span> <span class="nav-text">5.5 Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-HashMap"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">5.5.1 HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-HashTable"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">5.5.2 HashTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-Properties"><span class="nav-number">2.5.5.3.</span> <span class="nav-text">5.5.3 Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-4-TreeMap"><span class="nav-number">2.5.5.4.</span> <span class="nav-text">5.5.4 TreeMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">2.5.6.</span> <span class="nav-text">5.6 Collections工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.6.</span> <span class="nav-text">6. 泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">7. 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.1.</span> <span class="nav-text">7.1 基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.2.</span> <span class="nav-text">7.2 线程基本机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">2.7.3.</span> <span class="nav-text">7.3 线程终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.4.</span> <span class="nav-text">7.4 常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-1-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">7.4.1 线程中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-2-%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E4%B8%8E%E6%8F%92%E9%98%9F"><span class="nav-number">2.7.4.2.</span> <span class="nav-text">7.4.2 线程礼让与插队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-3-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.7.4.3.</span> <span class="nav-text">7.4.3 守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%83%E5%A4%A7%E7%8A%B6%E6%80%81"><span class="nav-number">2.7.4.4.</span> <span class="nav-text">7.4.4 线程的七大状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.4.5.</span> <span class="nav-text">7.4.5 线程同步机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-6-%E8%AF%BE%E5%A0%82%E7%BB%83%E4%B9%A0"><span class="nav-number">2.7.4.6.</span> <span class="nav-text">7.4.6 课堂练习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-IO%E6%B5%81"><span class="nav-number">2.8.</span> <span class="nav-text">8. IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.1.</span> <span class="nav-text">8.1 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.8.2.</span> <span class="nav-text">8.2 流的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">8.2.1 字节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-%E5%AD%97%E8%8A%82%E6%B5%81-1"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">8.2.1 字节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">8.2.3 节点流和处理流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-4-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">8.2.4 对象流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-5-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">2.8.2.5.</span> <span class="nav-text">8.2.5 输入输出</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Antarctica"
      src="/images/people.jpg">
  <p class="site-author-name" itemprop="name">Antarctica</p>
  <div class="site-description" itemprop="description">Antarctica Blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Antarctica000" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Antarctica000" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://antarctica.github.io/2024/05/26/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/people.jpg">
      <meta itemprop="name" content="Antarctica">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antarctica">
      <meta itemprop="description" content="Antarctica Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Antarctica">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-05-26 15:25:59 / 修改时间：15:39:45" itemprop="dateCreated datePublished" datetime="2024-05-26T15:25:59+08:00">2024-05-26</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr>
<hr>
<p>javaSE基础学习笔记<span id="more"></span></p>
<h1 id="第一阶段-基础语法"><a href="#第一阶段-基础语法" class="headerlink" title="第一阶段 基础语法"></a>第一阶段 基础语法</h1><h2 id="1-变量与运算符"><a href="#1-变量与运算符" class="headerlink" title="1. 变量与运算符"></a>1. 变量与运算符</h2><h3 id="1-1-转义字符课堂练习"><a href="#1-1-转义字符课堂练习" class="headerlink" title="1.1 转义字符课堂练习"></a>1.1 转义字符课堂练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为什么用了两个\t才行?这怎么回事?</span></span><br><span class="line"><span class="comment">//明白了\t就是四个字符的长度 中文字符比数字字符要长一半所以不行</span></span><br><span class="line">System.out.println(<span class="string">&quot;书名\t作者\t价格\t销量\n三国\t罗贯中\t120\t\t1000&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-“-”号的使用（字符串拼接）"><a href="#1-2-“-”号的使用（字符串拼接）" class="headerlink" title="1.2  “+”号的使用（字符串拼接）"></a>1.2  “+”号的使用（字符串拼接）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">100</span>+<span class="number">98</span>);<span class="comment">//左右两边均为数值 做加法运算</span></span><br><span class="line">System.out.println(<span class="string">&quot;100&quot;</span>+<span class="number">98</span>);<span class="comment">//只要有一方是字符串 则拼接两方</span></span><br><span class="line">System.out.println(<span class="number">100</span>+<span class="number">3</span>+<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>+<span class="number">100</span>+<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-浮点数运算比较的陷阱"><a href="#1-3-浮点数运算比较的陷阱" class="headerlink" title="1.3 浮点数运算比较的陷阱"></a>1.3 浮点数运算比较的陷阱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> num1=<span class="number">2.7</span>;</span><br><span class="line"><span class="type">double</span> num2=<span class="number">8.1</span>/<span class="number">3</span>;</span><br><span class="line"><span class="comment">//不能直接==,因为计算机的计算过程会将num2变为2.6999999...</span></span><br><span class="line"><span class="comment">//因此需要确定两小数相差小于某个精度时即可判断相等</span></span><br><span class="line"><span class="keyword">if</span>(Math.abs(num1-num2)&lt;<span class="number">0.0000001</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-char与byte"><a href="#1-4-char与byte" class="headerlink" title="1.4 char与byte"></a>1.4 char与byte</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char类型本质为整数 默认输出为编码表中对应的符号</span></span><br><span class="line"><span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println(ch+<span class="number">10</span>);<span class="comment">//所以可以直接加减</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte short char 无论自己还是相互进行运算的时候精度都会转为int</span></span><br><span class="line"><span class="type">byte</span> by1=<span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> sh1=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> bs=by1+sh1;</span><br><span class="line"><span class="type">byte</span> by2=<span class="number">1</span>;</span><br><span class="line">by2+=by1;</span><br><span class="line"><span class="comment">//复合赋值运算符通常会对右操作数进行隐式类型转换，以使其类型与左操作数相匹配，然后执行运算。</span></span><br><span class="line"><span class="type">byte</span> by3=(<span class="type">byte</span>)(by1+by2);</span><br><span class="line">System.out.println(by2);</span><br></pre></td></tr></table></figure>

<h3 id="1-5-字符串与基本数据类型的转换"><a href="#1-5-字符串与基本数据类型的转换" class="headerlink" title="1.5 字符串与基本数据类型的转换"></a>1.5 字符串与基本数据类型的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> number1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">number2</span> <span class="operator">=</span> Integer.parseInt(str2);</span><br><span class="line"><span class="type">double</span> <span class="variable">number3</span> <span class="operator">=</span> Double.parseDouble(str2);</span><br><span class="line"><span class="type">float</span> <span class="variable">number4</span> <span class="operator">=</span> Float.parseFloat(str2);</span><br><span class="line"><span class="type">byte</span> <span class="variable">number5</span> <span class="operator">=</span> Byte.parseByte(str2);</span><br><span class="line"><span class="type">short</span> <span class="variable">number6</span> <span class="operator">=</span> Short.parseShort(str2);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="type">char</span> <span class="variable">cha</span> <span class="operator">=</span> str2.charAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-6-运算符"><a href="#1-6-运算符" class="headerlink" title="1.6 运算符"></a>1.6 运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.1.1算数运算符</span></span><br><span class="line"><span class="comment">//自增自减面试题</span></span><br><span class="line"><span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> <span class="number">1</span>;               <span class="comment">//流程:1.temp=in</span></span><br><span class="line">in = in++;                <span class="comment">//     2.in=in+1</span></span><br><span class="line">System.out.println(in); <span class="comment">//     3.in=temp</span></span><br><span class="line"><span class="comment">//课堂练习2</span></span><br><span class="line"><span class="comment">//还有59天放假 合为几个星期多少天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> <span class="number">59</span> / <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">59</span> % <span class="number">7</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;合&quot;</span> + week + <span class="string">&quot;个星期零&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line"><span class="comment">//求出华氏温度对应的摄氏温度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">huaShi</span> <span class="operator">=</span> <span class="number">1234.6</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">sheShi</span> <span class="operator">=</span> <span class="number">5.0</span> / <span class="number">9</span> * (huaShi - <span class="number">100</span>);</span><br><span class="line">System.out.println(sheShi);<span class="comment">//如何保留两位小数?</span></span><br><span class="line"><span class="comment">//2.1.2(关系运算符过)逻辑运算符</span></span><br><span class="line"><span class="comment">//逻辑与和短路与 前者效率高 后者效率低</span></span><br><span class="line"><span class="type">int</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (aa &lt; <span class="number">1</span> &amp;&amp; ++bb&lt;<span class="number">50</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;aa=&quot;</span>+aa+<span class="string">&quot;bb=&quot;</span>+bb);</span><br><span class="line"><span class="keyword">if</span> (aa &lt; <span class="number">1</span> &amp; ++bb&lt;<span class="number">50</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;aa=&quot;</span>+aa+<span class="string">&quot;bb=&quot;</span>+bb);</span><br><span class="line"><span class="comment">//2.1.3关系运算符</span></span><br><span class="line"><span class="comment">//依然注意前后自增的返回关系(后自增先返回再自增)</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &gt; b ? ++a : b--;</span><br><span class="line">System.out.println(result+<span class="string">&quot; &quot;</span>+b);<span class="comment">//20 19</span></span><br><span class="line"><span class="comment">//2.1.4课堂练习</span></span><br><span class="line"><span class="comment">//三只小猪比大小</span></span><br><span class="line"><span class="type">int</span> n1=<span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n2=<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n3=<span class="number">65</span>;</span><br><span class="line"><span class="type">int</span> max1=n1&gt;n2?n1:n2;</span><br><span class="line"><span class="type">int</span> max2=n3&gt;max1?n3:max1;</span><br><span class="line">System.out.println(max2);</span><br></pre></td></tr></table></figure>

<h3 id="1-7-进制转换"><a href="#1-7-进制转换" class="headerlink" title="1.7 进制转换"></a>1.7 进制转换</h3><h3 id="1-8-原码-反码-补码（结合位运算符）"><a href="#1-8-原码-反码-补码（结合位运算符）" class="headerlink" title="1.8 原码 反码 补码（结合位运算符）"></a>1.8 原码 反码 补码（结合位运算符）</h3><p><strong>规则：</strong></p>
<ol>
<li><p>二进制的最高位是符号位（<code>0</code>表示正数<code>1</code>表示负数）</p>
</li>
<li><p>正数的原码 反码 补码都一样（三码合一）</p>
</li>
<li><p>负数的反码 &#x3D; 它的原码符号位不变，其它位取反<br>【<em>反码应对的是负数的问题 相当于将数轴倒过来前进后退 因此成功运算</em>】</p>
</li>
<li><p>负数的补码 &#x3D; 它的反码+1（反码 &#x3D; 补码 - 1）<br>【<em>补码应对的是<code>+0</code>（反码<code>0000 0000</code>）和<code>-0</code>（反码<code>1111 1111</code>）有两个的问题 为了使它们相等从而去掉一个 所以负数反码全部加一 正数没问题所以不用变</em>】</p>
</li>
<li><p><code>0</code>的反码 补码均为<code>0</code></p>
</li>
<li><p>计算机运算的时候，都是<strong>以补码的方式来运算</strong></p>
</li>
<li><p>当我们看运算结果的时候要<strong>看原码</strong></p>
</li>
</ol>
<p>所以两个字节的取值范围<code> -128</code>~&#96;127<code>的原因正是因为去掉一个</code>-0&#96;空出来一个补码的位置</p>
<table>
<thead>
<tr>
<th align="center">数</th>
<th align="center">原码</th>
<th align="center">反码</th>
<th align="center">补码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+0</td>
<td align="center">0000 0000</td>
<td align="center">0000 0000</td>
<td align="center">0000 0000</td>
</tr>
<tr>
<td align="center">-0</td>
<td align="center">1000 0000</td>
<td align="center">1111 1111</td>
<td align="center">0000 0000</td>
</tr>
<tr>
<td align="center">-1</td>
<td align="center">1000 0001</td>
<td align="center">1111 1110</td>
<td align="center">1111 1111</td>
</tr>
<tr>
<td align="center">-2</td>
<td align="center">1000 0010</td>
<td align="center">1111 1101</td>
<td align="center">1111 1110</td>
</tr>
<tr>
<td align="center">-127</td>
<td align="center">1111 1111</td>
<td align="center">1000 0000</td>
<td align="center">1000 0001</td>
</tr>
<tr>
<td align="center">-128</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">1000 0000</td>
</tr>
</tbody></table>
<p><strong>位运算符：</strong></p>
<p>按位与<code>&amp;</code> 、按位或<code>|</code> 、按位异或 <code>^</code>、 按位取反 <code>~</code>、算数右移 <code>&gt;&gt;</code>、算数左移 <code>&lt;&lt;</code>、无符号右移 <code>&gt;&gt;&gt;</code></p>
<h2 id="2-控制结构"><a href="#2-控制结构" class="headerlink" title="2. 控制结构"></a>2. 控制结构</h2><h3 id="2-1-switch语句"><a href="#2-1-switch语句" class="headerlink" title="2.1 switch语句"></a>2.1 switch语句</h3><p><strong>细节：</strong></p>
<ol>
<li>表达式数据类型要和case后面的常量类型一致（能自动转换也行）</li>
<li>表达式的返回值必须是byte、short、int、char、enum、String</li>
<li>case子句的值必须是常量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>课堂练习1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于成绩大于60分输出合格 低于60输出不合格</span></span><br><span class="line"><span class="comment">//要求必须使用switch(编程思想)</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> grade=sc.nextDouble();</span><br><span class="line"><span class="keyword">if</span>(grade&lt;<span class="number">0</span>||grade&gt;<span class="number">100</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Invalid !&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> ((<span class="type">int</span>)(grade/<span class="number">60</span>))&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不合格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;合格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>课堂练习2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定月份打印出对应季节(穿透)</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> month=sc.nextInt();</span><br><span class="line"><span class="keyword">switch</span> (month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-for语句"><a href="#2-2-for语句" class="headerlink" title="2.2  for语句"></a>2.2  for语句</h3><p><strong>编程思想：</strong></p>
<p>​    需求：打印1~100之间所有是9的倍数的整数，统计个数及总和</p>
<ol>
<li>化繁为简（复杂需求拆分为简单需求 逐步完成）<ul>
<li>先逐个输出<code>1~100</code>之间的所有值</li>
<li>在输出过程中进行过滤 只输出<code>9的倍数</code>（判断）</li>
<li>统计个数与总和，定义两个变量进行存储</li>
</ul>
</li>
<li>先死后活（先考虑固定值 然后转化为可以灵活变化的值）<ul>
<li>为了更好适应需求，把范围开始与结束的值抽成变量</li>
<li>进一步把<code>9的倍数</code>也抽成变量</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end=<span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count+<span class="string">&quot; &quot;</span>+sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>课堂练习1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; * &quot;</span> + i + <span class="string">&quot; = &quot;</span> + i * j + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>课堂练习2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空心金字塔</span></span><br><span class="line"><span class="comment">//先打印矩形 再打印半个金字塔 再将金字塔居中打印 再打印空心金字塔</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">//层数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">    <span class="comment">//输出*之前还要输出空格=总层数-当前层数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= row - i; j++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i * <span class="number">2</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == row || j == <span class="number">1</span> || j == i * <span class="number">2</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>课堂练习3：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1+(1+2)+(1+2+3)+...+(1+2+3+...+100)=?</span></span><br><span class="line"><span class="comment">//双层循环思想 还可以用等差数列和公式简化时间复杂度</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        sum+=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<h2 id="3-数组-排序-查找"><a href="#3-数组-排序-查找" class="headerlink" title="3. 数组 排序 查找"></a>3. 数组 排序 查找</h2><h3 id="3-1-数组扩容"><a href="#3-1-数组扩容" class="headerlink" title="3.1 数组扩容"></a>3.1 数组扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arrNew = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arrNew[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">arrNew[arr.length - <span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">arr = arrNew;<span class="comment">//arr指向新数组 于是原来的数组会自动销毁</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-二维数组"><a href="#3-2-二维数组" class="headerlink" title="3.2  二维数组"></a>3.2  二维数组</h3><p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] x,y[];</span><br></pre></td></tr></table></figure>

<p>其中<code>x</code>是int类型得一维数组，<code>y</code>是int类型的二维数组<br>若<code>y[0]=x</code>正确（ int[] –&gt; int[] ），<code>y[0][0]=x[0]</code>正确（ int –&gt; int ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建二维数组 但只确定一维数组个数</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];<span class="comment">//给每个一维数组开空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        arr[i][j] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//杨辉三角</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || j == arr[i].length - <span class="number">1</span>)</span><br><span class="line">            arr[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr[i][j] = arr[i - <span class="number">1</span>][j] + arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">23</span>, <span class="number">76</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">88</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tem</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4. 面向对象"></a>4. 面向对象</h2><h3 id="4-1-成员方法"><a href="#4-1-成员方法" class="headerlink" title="4.1 成员方法"></a>4.1 成员方法</h3><p><strong>递归练习：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列求第n个数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num=fi(<span class="number">7</span>);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fi</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fi(n-<span class="number">1</span>)+fi(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猴子吃桃子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(peach(<span class="number">10</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">peach</span><span class="params">(<span class="type">int</span> day,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==day)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (peach(<span class="number">10</span>,++i)+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老鼠走迷宫(求出最短路径 穷举/BFS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1.先创建迷宫(二维数组)</span></span><br><span class="line">    <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="comment">//2.设置障碍物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">        map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//走迷宫</span></span><br><span class="line">    findWay(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//输出当前地图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map[i].length; j++) &#123;</span><br><span class="line">            System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出迷宫的路径 找到即为true</span></span><br><span class="line"><span class="comment">//i和j为老鼠位置 0 可以走 1 障碍物 2 走过标记 3 走过但是死路</span></span><br><span class="line"><span class="comment">//走路策略:下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findWay</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        map[i][j]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (findWay(map, i + <span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i - <span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map[i][j] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//汉诺塔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    move(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    move(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">    System.out.println(a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">    move(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八皇后问题(待解决)</span></span><br></pre></td></tr></table></figure>

<p><strong>重载：</strong></p>
<ol>
<li>方法名必须相同</li>
<li>参数列表必须不同（类型或个数或顺序）</li>
<li>返回类型无要求</li>
</ol>
<p><strong>可变参数：</strong>（可以当作数组来看）</p>
<ol>
<li>可变参数的实参可以为0到任意多</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数必须放在<strong>最后</strong>，且一个形参列表中<strong>只能有一个</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">var</span><span class="params">(<span class="type">int</span>...nums)</span>&#123;</span><br><span class="line">    System.out.println(nums.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-作用域"><a href="#4-2-作用域" class="headerlink" title="4.2 作用域"></a>4.2 作用域</h3><ol>
<li>java编程中，主要的变量就是属性（成员变量）和局部变量</li>
<li>全局变量可以不赋值，直接使用（因为有默认值）而局部变量必须赋值后才能使用（没有默认值）</li>
<li>属性和局部变量可以重名，访问时就近原则</li>
<li>作用域范围不同：属性可以被本类和其他类使用（对象名调用），局部变量只能本类</li>
<li>修饰符：属性可以加修饰符，局部变量不可以</li>
</ol>
<h3 id="4-3-构造器（Constructor）"><a href="#4-3-构造器（Constructor）" class="headerlink" title="4.3 构造器（Constructor）"></a>4.3 构造器（Constructor）</h3><ol>
<li><p>作用：完成对象的初始化</p>
</li>
<li><p>构造器没有返回值</p>
</li>
<li><p>方法名和类名必须一致</p>
</li>
<li><p>构造器的调用由系统完成（new的时候系统完成）</p>
</li>
<li><p>一个类可以定义多个不同的构造器（构造器重载）</p>
</li>
<li><p>一旦使用自己的构造器，就覆盖了默认无参构造器（javap），除非自行再显式声明</p>
</li>
</ol>
<p><strong>对象创建流程：</strong></p>
<ol>
<li>加载Person类信息（Person.class）只会加载一次</li>
<li>在堆中分配空间（地址）</li>
<li>完成对象初始化<ul>
<li>默认初始化（age&#x3D;0 name&#x3D;null）</li>
<li>显式初始化（age&#x3D;90 name&#x3D;null）</li>
<li>构造器的初始化（age&#x3D;20 name&#x3D;五一寒）</li>
</ul>
</li>
<li>将对象在堆中的地址返回给p（对象的引用）</li>
</ol>
<p><strong>this：</strong>哪个对象调用，this就代表那个对象（可以看作this存储对象地址）<br>           无法获取this的地址，但是可以this.hashcode近似看一下</p>
<ol>
<li>this可以访问本类的属性、方法、构造器</li>
<li>访问成员方法的语法：this.方法名(参数列表)</li>
<li>访问构造器语法：this(参数列表)（只能在构造器中使用，且必须放在第一行）</li>
<li>this只能在类定义的方法中使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器复用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,<span class="type">char</span> gender,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.gender=gender;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String job,String salary)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.job=job;</span><br><span class="line">    <span class="built_in">this</span>.salary=salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,<span class="type">char</span> gender,<span class="type">int</span> age,String job,String salary)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(name,gender,age);<span class="comment">//只能用一个</span></span><br><span class="line">    <span class="built_in">this</span>.job=job;</span><br><span class="line">    <span class="built_in">this</span>.salary=salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-包"><a href="#4-4-包" class="headerlink" title="4.4 包"></a>4.4 包</h3><p><strong>作用：</strong></p>
<ol>
<li>区分相同名字的类</li>
<li>类很多时可以很好地管理类</li>
<li>控制访问范围</li>
<li>命名规范：只能包含数字 字母 下划线 小圆点 但是不能用数字开头 不能是关键字保留字</li>
</ol>
<h3 id="4-5-访问修饰符"><a href="#4-5-访问修饰符" class="headerlink" title="4.5 访问修饰符"></a>4.5 访问修饰符</h3><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">不同包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">O</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p><strong>细节：</strong>只有默认和public才可以修饰类</p>
<h3 id="4-6-封装"><a href="#4-6-封装" class="headerlink" title="4.6 封装"></a>4.6 封装</h3><ol>
<li>隐藏实现细节</li>
<li>可以<strong>对数据进行验证</strong>，保证安全合理<br>例如set时可以增加数据合理判断<br>get时可以加入权限判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装与构造器结合</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setAge(age);</span><br><span class="line">    <span class="built_in">this</span>.setName(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-继承"><a href="#4-7-继承" class="headerlink" title="4.7 继承"></a>4.7 继承</h3><ol>
<li>子类继承父类属性和方法（除了构造器、final<strong>修饰的类</strong>），但是私有属性不能在子类直接访问，要通过公共的方法去访问。</li>
<li>子类必须调用父类的构造器，完成父类的初始化。<br>创建子类对象时，默认情况下总会去调用父类的无参构造器，若父类没有提供无参构造，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译错误。</li>
<li>super()和this()都必须放在第一行 因此二者不能共存</li>
<li>Object是所有类的基类</li>
<li>父类构造器的调用不限于直接父类 将一直往上追溯到Object</li>
<li>子类只能有一个直接父类（单继承）</li>
</ol>
<p><strong>本质：</strong></p>
<p>当子类的对象被创建好之后，建立查找关系</p>
<p><strong>super：</strong></p>
<ol>
<li>代表父类的引用，用于访问父类的属性、方法、构造器<br>不能访问父类private，且super只能放在构造器第一句，一次。</li>
<li>super访问不限于父类，若多个基类都有同名成员，则就近访问</li>
<li>好处：<ul>
<li>分工明确，父类属性由父类初始化 子类特有再自己初始化。</li>
<li>子类有和父类成员重名时，必须通过super访问。不重名皆可。</li>
</ul>
</li>
</ol>
<p><strong>this与super比较：</strong></p>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问属性</td>
<td align="center">访问本类属性，若本类没有则从父类中继续查找</td>
<td align="center">从父类开始查找属性</td>
</tr>
<tr>
<td align="center">调用方法</td>
<td align="center">访问本类方法，如果本类没有则从父类中继续查找</td>
<td align="center">从父类开始查找方法</td>
</tr>
<tr>
<td align="center">调用构造器</td>
<td align="center">调用本类构造器，必须放在首行</td>
<td align="center">调用父类构造器，必须放在子类构造器首行</td>
</tr>
<tr>
<td align="center">特殊</td>
<td align="center">表示当前对象</td>
<td align="center">子类中访问父类对象</td>
</tr>
</tbody></table>
<p><strong>方法重写override：</strong></p>
<ol>
<li>子类方法参数、方法名要和父类<strong>完全一样</strong></li>
<li>子类方法<strong>返回类型</strong>要一样或者是父类方法返回类型的子类</li>
<li>子类方法不能缩小父类方法的<strong>访问权限</strong></li>
</ol>
<h3 id="4-8-多态"><a href="#4-8-多态" class="headerlink" title="4.8 多态"></a>4.8 多态</h3><p>提高代码复用性，利于代码维护。</p>
<p><strong>方法的多态：</strong>重写（<strong>调用者</strong>不同）和重载（参数列表不同）</p>
<p><strong>对象的多态：</strong></p>
<ol>
<li>一个对象的编译类型和运行类型可以不一致<br>例：Animal animal &#x3D; new Dog ( ) </li>
<li>编译类型在确定对象时就确定了。不能改变</li>
<li>运行类型是可以变化的</li>
<li>编译类型看定义时 &#x3D; 号的左边，运行类型看 &#x3D; 号的右边</li>
<li><strong>属性</strong>的值看编译类型，没有重写之说</li>
<li>instanceOf 比较操作符，用于判断对象的运行类型是否为XX类型或它的子类型</li>
</ol>
<p><strong>向上转型：</strong></p>
<ol>
<li>本质：父类引用指向子类的对象</li>
<li>语法：父类类型 引用名 &#x3D; new 子类类型</li>
<li>特点：可以调用父类中所有成员（遵循访问权限）<br>        不能调用子类中特有成员（因为编译阶段javac能调用哪些成员，是由编译类型决定的）<br>        最终运行效果看子类的具体实现（已编译完成 看运行类型）</li>
</ol>
<p><strong>向下转型：</strong></p>
<ol>
<li>语法：子类类型 引用名 &#x3D; （子类类型）父类引用</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>向下转型后，可以调用子类类型中所有的成员</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">animal.eatFish();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;<span class="comment">//animal原来指向的本来就要是猫</span></span><br><span class="line">cat.catchMouse();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWork</span><span class="params">(Employee e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Worker)</span><br><span class="line">        ((Worker) e).work();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Manager)</span><br><span class="line">        ((Manager) e).manage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><mark>动态绑定机制：</mark></strong></p>
<ol>
<li>当调用对象方法时，该方法会和该对象的运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪声明哪使用（作用域）</li>
</ol>
<p><strong>多态数组：</strong></p>
<p>数组的定义类型为父类类型，里面保存的实际元素为子类类型</p>
<p><strong>equals：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写equals方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//运行类型是Person才进入比较</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="comment">//向下转型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二阶段-面向对象"><a href="#第二阶段-面向对象" class="headerlink" title="第二阶段 面向对象"></a>第二阶段 面向对象</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h2><p>（五大成员：属性、方法、代码块、构造器、内部类）</p>
<h3 id="1-1-类变量与类方法"><a href="#1-1-类变量与类方法" class="headerlink" title="1.1 类变量与类方法"></a>1.1 类变量与类方法</h3><p><strong>static变量</strong></p>
<p><strong>需求：</strong>对象共享一个数据空间（数据与对象产生联系）<br><strong>本质：</strong>放在堆里面的一个空间，通过反射机制加载一个class对象，存储在堆里面class实例的尾部。（在 Java 8 之前，静态变量确实是存储在堆中的一部分。但是，从 Java 8 开始，随着永久代（Permanent Generation）的移除，静态变量被移动到了方法区（Metaspace））<br><strong>细节：</strong></p>
<ol>
<li>随着类的加载而创建，只会加载一次（静态属性只会初始化一次）</li>
<li>类变量的生命周期随着类的加载开始，随类的消亡销毁</li>
<li>类变量 &#x2F; 静态变量与实例变量 &#x2F; 普通变量 &#x2F; 非静态变量 &#x2F; 属性：类变量共享，实例变量每个对象独享</li>
</ol>
<p><strong>类方法</strong></p>
<p><strong>使用场景：</strong>当方法中不涉及到任何和对象相关的成员，可以设计为静态方法提高开发效率。（工具类）</p>
<p><strong>细节：</strong></p>
<ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区</li>
<li>类方法中无<code>this</code>参数（对象有关的东西都不行）<br>普通方法中隐含<code>this</code>参数</li>
<li>静态方法只能访问静态成员，非静态都可以</li>
</ol>
<p><strong>main方法：</strong></p>
<ol>
<li>main方法由java虚拟机调用，所以访问权限必须是public</li>
<li>JVM在执行main方法时不必创建对象，所以必须static</li>
</ol>
<h3 id="1-2-代码块："><a href="#1-2-代码块：" class="headerlink" title="1.2 代码块："></a>1.2 代码块：</h3><p>又称初始化块，属于类中的成员（类的一部分）类似于只有方法体的方法，但是不通过对象或类显式调用，而是加载类、创建对象时隐式调用。<br>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作。例如多个构造器都有重复的语句，可以抽取。</p>
<p><strong>细节：</strong></p>
<ol>
<li>static代码块（静态代码块），作用是对类进行初始化，随着<mark>类的加载</mark>而执行，并且只会执行一次（单例模式！）</li>
<li>普通代码块 创建一个对象就会执行一次（在创建对象实例时会被隐式调用）</li>
</ol>
<p><strong><mark>类什么时候被加载？</mark></strong></p>
<ol>
<li>创建对象实例的时候（new）</li>
<li>创建子类对象实例，父类也被加载</li>
<li>使用类的静态成员时（静态方法、静态属性）</li>
</ol>
<p><mark><strong>创建一个对象时在类中的调用顺序：</strong></mark></p>
<ol>
<li>调用静态代码块和静态属性<strong>初始化</strong>（优先级相同，若有多个则按定义的顺序调用）</li>
<li>调用普通代码块和普通属性的<strong>初始化</strong>（同上）</li>
<li>调用构造方法（构造器的最前面隐含了super() 和调用普通代码块）</li>
</ol>
<p><strong>单例设计模式：</strong></p>
<ol>
<li><p>（单个的实例）采取一定方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
</li>
<li><p>饿汉式 &#x2F; 懒汉式</p>
</li>
<li><p>步骤：</p>
<ul>
<li>构造器私有化（防止用户去new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lover</span> &#123;<span class="comment">//饿汉式单例模式</span></span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="comment">//2.类的内部直接创建</span></span><br><span class="line">    <span class="comment">//3.提供一个公共的static方法返回lv对象</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lover lv=<span class="keyword">new</span> <span class="title class_">Lover</span>(<span class="string">&quot;my love&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lover <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lover</span> &#123;<span class="comment">//懒汉式单例模式</span></span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="comment">//2.定义静态属性</span></span><br><span class="line">    <span class="comment">//3.提供一个公共的static方法返回lv对象</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lover lv;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;<span class="comment">//多个线程可能抢占同时创建对象(加锁解决)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lover <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lv == <span class="literal">null</span>)</span><br><span class="line">            lv = <span class="keyword">new</span> <span class="title class_">Lover</span>(<span class="string">&quot;my love&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>二者区别：创建对象的时机不同，饿汉式在类加载时就创建了对象，懒汉式在使用时才创建</li>
<li>懒汉式存在线程安全问题</li>
<li>饿汉式存在资源浪费可能</li>
<li>javaSE标准类中，java.lang.Runtime就是经典的单例模式</li>
</ol>
</li>
</ol>
<p><strong>final</strong></p>
<ol>
<li><p>不希望类被继承时用<code>final</code>修饰</p>
</li>
<li><p>不希望父类某个方法被子类覆盖 &#x2F; 重写时</p>
</li>
<li><p>不希望类的某个属性值被修改（常量）</p>
</li>
<li><p>不希望某个局部变量被修改（局部常量）</p>
<p><strong>细节：</strong></p>
</li>
<li><p>定义时就要赋初值，且不能再修改<br>可在构造器、代码块中赋初值（若是static则不能再构造器中赋值）</p>
</li>
<li><p>final不可以继承，但可以实例化对象</p>
</li>
<li><p>类不是final类，但是含有final方法，那么该方法不能被重写但可被继承</p>
</li>
<li><p>final不能修饰构造器</p>
</li>
<li><p>final和static往往搭配使用效率更高，因为底层做了相应的优化，不会导致类的加载</p>
</li>
</ol>
<h3 id="1-3-抽象类"><a href="#1-3-抽象类" class="headerlink" title="1.3 抽象类"></a>1.3 抽象类</h3><p><strong>细节：</strong></p>
<ol>
<li>抽象方法不能有方法体</li>
<li>抽象方法不能使用private、static、final修饰（因为必须要被重写）</li>
<li><code>abstract</code>只能修饰类和方法</li>
<li>抽象类不一定由抽象方法，有抽象方法的必须声明为抽象类</li>
<li>一个非抽象类继承了抽象类，则需要实现其中所有抽象方法</li>
</ol>
<p><strong>使用场景：</strong>模板设计模式（提高代码复用性）</p>
<h3 id="1-4-接口"><a href="#1-4-接口" class="headerlink" title="1.4 接口"></a>1.4 接口</h3><p><strong>细节：</strong></p>
<p>（可以理解为是对于单继承机制的一种补充）</p>
<ol>
<li>接口不能被实例化</li>
<li>接口只能用public或默认（和类一样）</li>
<li>接口中所有方法都是public</li>
<li>在接口中，抽象方法可以省略abstract、public</li>
<li>接口中所有的属性必须是public static final（可不写）</li>
<li>JDK8之后可以有default修饰默认实现方法，和静态方法（有方法体）</li>
<li>一个普通类实现接口，必须重写所有方法（抽象类可以不用）</li>
</ol>
<p><strong>实现接口VS继承</strong></p>
<p>继承：解决代码的复用性和可维护性<br>接口：设计好各种规范（方法），让其他类去实现这些方法<br>接口在一定程度上实现代码解耦（接口规范+动态绑定）<br>接口比继承更灵活</p>
<p><strong>接口多态：</strong></p>
<ol>
<li><p><strong>多态参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        Computer computer=<span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        work(phone);</span><br><span class="line">        work(computer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(IG ig)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;working...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">IG</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多态数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        IG[] igs=<span class="keyword">new</span> <span class="title class_">IG</span>[<span class="number">2</span>];</span><br><span class="line">        igs[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        igs[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; igs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(igs[i] <span class="keyword">instanceof</span> Phone)</span><br><span class="line">                ((Phone) igs[i]).call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span>&#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;phone is calling...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">IG</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多态传递</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span> &#123; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-5-内部类"><a href="#1-5-内部类" class="headerlink" title="1.5 内部类"></a>1.5 内部类</h3><h5 id="1-5-1-局部内部类（外部类的局部位置上，有类名）"><a href="#1-5-1-局部内部类（外部类的局部位置上，有类名）" class="headerlink" title="1.5.1 局部内部类（外部类的局部位置上，有类名）"></a>1.5.1 局部内部类（外部类的局部位置上，有类名）</h5><ol>
<li>可以直接访问外部类的所有成员</li>
<li>外部类访问局部内部类方法等同于外部访问类（作用域内）</li>
<li>不能添加访问修饰符（因为它的<strong>地位就是一个局部变量</strong>，而局部变量不能使用访问修饰符。但是可以使用final修饰）</li>
<li>若与外部类的成员重名，则访问使用（外部类.this.成员）</li>
</ol>
<h5 id="1-5-2-匿名内部类（外部类的成员位置上，无类名）"><a href="#1-5-2-匿名内部类（外部类的成员位置上，无类名）" class="headerlink" title="1.5.2 匿名内部类（外部类的成员位置上，无类名）"></a>1.5.2 <mark>匿名内部类</mark>（外部类的成员位置上，无类名）</h5><p><strong>本质：</strong>既是一个类的定义，同时本身也是一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于接口的匿名内部类(基于类的话要写参数列表)</span></span><br><span class="line"><span class="comment">//编译类型IA,运行类型TEST$1(系统分配)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        IA tiger=<span class="keyword">new</span> <span class="title class_">IA</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;tiger eating...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//动态绑定,找到第7行</span></span><br><span class="line">        tiger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong><br>当作实参直接传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">IA</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IA ia)</span>&#123;</span><br><span class="line">        ia.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-5-3-成员内部类（外部类的成员位置上，无static）"><a href="#1-5-3-成员内部类（外部类的成员位置上，无static）" class="headerlink" title="1.5.3 成员内部类（外部类的成员位置上，无static）"></a>1.5.3 成员内部类（外部类的成员位置上，无static）</h5><p><strong>细节：</strong>定义在外部类的成员位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> Outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"><span class="comment">//第二种方式(外部类里定义创建并返回内部类的方法)</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> Outer.getInner();</span><br></pre></td></tr></table></figure>

<h5 id="1-5-4-静态内部类（外部类的成员位置上，有static）"><a href="#1-5-4-静态内部类（外部类的成员位置上，有static）" class="headerlink" title="1.5.4 静态内部类（外部类的成员位置上，有static）"></a>1.5.4 静态内部类（外部类的成员位置上，有static）</h5><p><strong>细节：</strong>相比于成员内部类就是多了一个static（记住静态方法只能访问静态成员）</p>
<h2 id="2-枚举与注解"><a href="#2-枚举与注解" class="headerlink" title="2. 枚举与注解"></a>2. 枚举与注解</h2><h3 id="2-1-枚举"><a href="#2-1-枚举" class="headerlink" title="2.1 枚举"></a>2.1 枚举</h3><ol>
<li>枚举是一组常量的集合</li>
<li>枚举属于一种特殊的类，里面只包含一组有限的特定对象</li>
</ol>
<p><strong>自定义枚举：</strong></p>
<ol>
<li>私有化构造器</li>
<li>枚举对象&#x2F;属性使用static+final底层优化（只加载一次）</li>
<li>命名全部大写符合规范</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(Season.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name,String type)</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>enum：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br></pre></td></tr></table></figure>

<p><strong>细节：</strong></p>
<ol>
<li><p>默认继承Enum类，且此类本质是final</p>
</li>
<li><p>调用的是构造器</p>
</li>
<li><p>若多个无参构造器创建枚举对象，则实参列表和小括号均可省略</p>
</li>
<li><p>枚举对象必须放在行首</p>
</li>
<li><p>使用枚举之后不能再继承其他类（因为已经隐式继承Enum）可以实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    BOY,GILR;</span><br><span class="line">&#125;<span class="comment">//这样写是正确的</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>父类方法：</strong></p>
<ol>
<li><p>name：返回当前对象名</p>
</li>
<li><p>ordinal：返回当前对象的位置号，默认从0开始</p>
</li>
<li><p>values：返回当前枚举类中的所有常量</p>
</li>
<li><p>valueOf：将字符串转换为枚举对象，要求字符串必须为已有的常量名，否则报异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season2</span> <span class="variable">autumn</span> <span class="operator">=</span> Season2.AUTUMN;</span><br><span class="line"><span class="type">Season2</span> <span class="variable">autumn1</span> <span class="operator">=</span> Season2.valueOf(<span class="string">&quot;AUTUMN&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>（此处两个变量是同一个，2行找到了就返回在枚举类找到的对象，所以是同一个）</p>
</li>
<li><p>compareTo：比较两个枚举常量，比较的是位置号</p>
</li>
</ol>
<p><strong>练习：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Week</span> <span class="variable">monday</span> <span class="operator">=</span> Week.MONDAY;</span><br><span class="line">        Week[] days = Week.values();</span><br><span class="line">        <span class="keyword">for</span> (Week day : days) &#123;</span><br><span class="line">            System.out.println(day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;周一&quot;</span>), TUESDAY(<span class="string">&quot;周二&quot;</span>), WEDNESDAY(<span class="string">&quot;周三&quot;</span>), THURSDAY(<span class="string">&quot;周四&quot;</span>), FRIDAY(<span class="string">&quot;周五&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解：</strong></p>
<ol>
<li>也成为元数据，用于修饰解释 包 类 方法 属性 构造器 局部变量等数据信息</li>
<li>和注释一样，但注解可以被编译和运行，相当于嵌入在代码中的补充信息</li>
<li>目的：标记过时的功能、忽略警告等</li>
</ol>
<p><strong>三个基本的Annotation：</strong></p>
<ol>
<li><p>@Override 重写父类方法（该注解只能用于方法）<br>编译器会去检查该方法是否真的重写了父类方法，若没有构成重写则报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override&#123;</span><br><span class="line">    <span class="comment">//这不是接口，这是注解类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Target修饰注解的注解，称为元注解</p>
</li>
<li><p>@Deprecated 修饰某个过时的元素</p>
</li>
<li><p>@SuppressWarnings 抑制警告</p>
</li>
</ol>
<p><strong>章节练习：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.按要求实现对象的属性值递增100</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Frock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> currentNum=<span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> serialNumber;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNextNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentNum+=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Frock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.serialNumber=getNextNum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSerialNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.匿名内部类实现计算方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Phone</span>().testWork(<span class="keyword">new</span> <span class="title class_">Calculate</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n1 + n2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span> &#123;</span><br><span class="line">    <span class="comment">//work方法功能是运算,具体什么运算交给匿名内部类(用户)实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//直接传入一个实现了接口的匿名内部类即可,该匿名内部类可以灵活的实现work,完成不同的计算任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork</span><span class="params">(Calculate calculate, <span class="type">double</span> n1, <span class="type">double</span> n2)</span> &#123;</span><br><span class="line">        System.out.println(calculate.work(n1, n2));<span class="comment">//动态绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.唐僧骑马还是坐船(编程思想与程序结构)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person person=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wa&quot;</span>,<span class="keyword">new</span> <span class="title class_">Horse</span>());</span><br><span class="line">        person.passRiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">Vehicles</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;horse working&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boat</span> <span class="keyword">implements</span> <span class="title class_">Vehicles</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//创建工厂类是没意义的,所以用static直接类名调用方法</span></span><br><span class="line">    <span class="comment">//不能每次调用都创建一匹新马(单例模式饿汉)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Horse horse=<span class="keyword">new</span> <span class="title class_">Horse</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Boat boat=<span class="keyword">new</span> <span class="title class_">Boat</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Factory</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Horse <span class="title function_">getHorse</span><span class="params">()</span> &#123;<span class="keyword">return</span> horse;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boat <span class="title function_">getBoat</span><span class="params">()</span> &#123;<span class="keyword">return</span> boat;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Vehicles vehicles;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Vehicles vehicles)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.vehicles = vehicles;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passRiver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(vehicles <span class="keyword">instanceof</span> Horse))<span class="comment">//包含了为空的情况</span></span><br><span class="line">            vehicles=Factory.getBoat();<span class="comment">//多态</span></span><br><span class="line">        vehicles.work();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">common</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h2><p><strong>Error：</strong>Java虚拟机无法解决的严重问题：JVM系统错误、资源耗尽等严重情况（StackOverflowError 、OOM）</p>
<p><strong>Exception：</strong>其它因为编程错误或偶然因素导致的一般性问题（编译时异常与运行时异常）</p>
<p><strong>异常体系图：</strong></p>
<p>Throwable实现Serializable接口，继承Object。<br>Error和Exception继承Tdhrowable。<br>IOException ClassNotFoundException RuntimeExceptiond等继承Exception。<br>ArithmeticException ClassCastException IndexOutOfBoundException NullPointerException ArithmeticFormatException等继承RuntimeException.</p>
<p><strong>异常处理机制：</strong><br>try-catch-finally（自己处理）或者throws（踢皮球）二选一<br>若没有显式写出，那么默认throws</p>
<p><strong>细节：</strong></p>
<ol>
<li>编译异常（例如IOException）必须手动处理</li>
<li>运行异常不处理就默认throw</li>
<li>子类重写夫方法时抛出的异常一致或者子类</li>
</ol>
<p><strong>try-catch：</strong></p>
<ol>
<li>可以有多个catch语句，捕获不同的异常（进行不同的业务处理）要求父类异常在后，子类异常在前。</li>
<li>可以直接try-finally配合使用，程序会直接崩掉，但是一定会执行想要执行的代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求用户一定输入一个整数</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入整数&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num=Integer.parseInt(sc.next());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;要求输入整数!&quot;</span>);&#125;&#125;</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p><strong>throw：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> age=sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(!(age&gt;=<span class="number">18</span>&amp;&amp;age&lt;=<span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄不规范&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正确&quot;</span>);&#125;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>throw和throws区别：</strong><br>throw是手动生成异常的关键字，位于方法体内，后面跟的是异常对象。<br>thirows是异常的一种处理方式，位于方法声明处，后面跟的是异常类型。</p>
<h2 id="4-常用类"><a href="#4-常用类" class="headerlink" title="4. 常用类"></a>4. 常用类</h2><h3 id="4-1-包装类"><a href="#4-1-包装类" class="headerlink" title="4.1 包装类"></a>4.1 包装类</h3><p><strong>自动装箱：</strong>（底层依然是valueOf方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> n2;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类 -&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;<span class="comment">//运算符自动转</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();<span class="comment">//Integer类方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);<span class="comment">//String方法</span></span><br><span class="line"><span class="comment">//String -&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.parseInt(s);<span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s);<span class="comment">//构造器</span></span><br></pre></td></tr></table></figure>

<p><strong>Integer：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;<span class="comment">//valueOf和直接new不一样喔</span></span><br></pre></td></tr></table></figure>

<p>可以得出，若创建时数字范围是-128~127内，直接从缓存数组返回（static），不创建新的对象，其他就new一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">sout(i1 == <span class="number">12</span>);<span class="comment">//false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">sout(i3 == i);<span class="comment">//true 只要有基本数据类型就比值</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-String"><a href="#4-2-String" class="headerlink" title="4.2 String"></a>4.2 String</h3><ol>
<li><p>继承关系：<code>Object</code>的子类，实现了接口：<code>Serializable</code>（可以串行化 在网络上传输） <code>Comparable</code> （可以相互比较）<code>CharSequence</code></p>
</li>
<li><p><code>String name = “jack”;</code>其中等号左边是变量，右边是字符串常量 ，使用Unicode编码，一个字符占两字节</p>
</li>
<li><p>属性 private <strong>final</strong> char value [ ] 用于存放字符串内容，不可修改（地址 不能指向另外一个对象）</p>
</li>
<li><p>常见两种创建String对象的方式：</p>
<ul>
<li>直接赋值 <code>String s = “wyh”;</code><br>先从常量池查看是否有<code>“wyh”</code>数据空间，如果有则直接指向，没有则重新创建，然后指向（最终<code>s</code>指向常量池的空间地址）</li>
<li>调用构造器<code>String s = new String(&quot;wyh&quot;);</code><br>先在堆中创建空间，里面维护了value属性，指向常量池的<code>wyh</code>空间。若没有，则重新创建。若有，直接通过value指向（最终<code>s</code>指向堆中的空间地址）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存分析练习题</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.name = <span class="string">&quot;wyh&quot;</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p2.name = <span class="string">&quot;wyh&quot;</span>;</span><br><span class="line">sout(p1.name.equals(p2.name));<span class="comment">//T</span></span><br><span class="line">sout(p1.name == p2.name);<span class="comment">//T(引用)</span></span><br><span class="line">sout(p1.name == <span class="string">&quot;wyh&quot;</span>);<span class="comment">//T</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">sout(s1 == s2);<span class="comment">//F(对象)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串是不可变的，一个字符串对象被分配后内容不可变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hahaha&quot;</span></span><br><span class="line"><span class="comment">//创建了两个对象,&quot;hello&quot;对象垃圾回收了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//并没有创建三个对象,编译器会在底层优化,一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;<span class="comment">//共3个对象</span></span><br><span class="line"><span class="comment">//1.先创建StringBuilder </span></span><br><span class="line"><span class="comment">//2.再sb.append()</span></span><br><span class="line"><span class="comment">//3.String c = sb.toString()</span></span><br><span class="line"><span class="comment">//本质:c指向堆中的对象(String)value[] -&gt; 池中的&quot;aaabbb&quot;,c仍然是new的感觉</span></span><br><span class="line"><span class="comment">//因此 常量相加在池 变量相加在堆</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常用方法：</strong></p>
<ul>
<li><code>equals</code> <code>equalsIgnoreCase</code>  <code>length</code>  <code>indexOf</code>  <code>lastIndexOf</code>  <code>substring</code>  <code>trim</code>  <code>charAt</code>  <code>toCharArray</code>  <code>toUpperCase</code>  <code>toLowerCase</code>  <code>concat</code>  <code>replace</code>  <code>split</code> <code>compareTo</code>  <code>format</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Han shun Ping&quot;</span>;</span><br><span class="line">    print(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">    String[] names=str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(names.length!=<span class="number">3</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;格式不对&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">    String format=String.format(<span class="string">&quot;%s,%s.%c&quot;</span>,names[<span class="number">2</span>],names[<span class="number">0</span>],names[<span class="number">1</span>].toUpperCase().charAt(<span class="number">0</span>));</span><br><span class="line">    System.out.println(format);&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String类是用来保存字符串常量的，每次更新都需要重新开辟空间，效率低下，因此有了StringBuilder和StringBuffer来增强String的功能</p>
</li>
</ol>
<h3 id="4-3-StringBuffer"><a href="#4-3-StringBuffer" class="headerlink" title="4.3 StringBuffer"></a>4.3 StringBuffer</h3><ol>
<li>继承关系：sbf继承AbstractStringBuilder，可以串行化，有属性char[] value（不是final），存放在堆中sbf是final</li>
<li>String保存的是字符串常量，里面的值不能修改，每次更新都要重新更改地址，效率低。StringBuffer的char直接指向堆可以直接更新内容，容量不够才会扩容</li>
<li><strong>String -&gt; StringBuffer</strong><br><code>StringBuffer sbf = new StringBuffer(str);</code><br><code>sbf.append(str);</code><br><strong>StringBuffer -&gt; String</strong><br><code>String str = sbf.toString();</code><br><code>String str = new String(sbf);</code></li>
<li>常见方法：（增删改查插）<br><code>append</code> <code>delete</code> <code>replace</code> <code>indexOf</code> <code>insert</code> <code>length</code></li>
</ol>
<p><strong>课堂练习：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);<span class="comment">//不会异常 源码处理拼接了&quot;null&quot;</span></span><br><span class="line">sout(sb.length());<span class="comment">//4</span></span><br><span class="line"><span class="comment">//会抛出异常 因为确定容量时获取长度 空指针异常</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入金额小数点前每三位加入逗号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">    sb.append(ch[i]);</span><br><span class="line">    <span class="keyword">if</span> (i&lt; ch.length-<span class="number">1</span>&amp;&amp;ch[i + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>);&#125;&#125;&#125;</span><br><span class="line"><span class="comment">//想法太死了,只用到了sbd的拼接,没灵活使用其他功能</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>(sc.next());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sb.indexOf(<span class="string">&quot;.&quot;</span>)-<span class="number">3</span>; i &gt; <span class="number">0</span>; i-=<span class="number">3</span>)</span><br><span class="line">    sb.insert(i,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(sb);<span class="comment">//这就很好</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-StringBuilder"><a href="#4-4-StringBuilder" class="headerlink" title="4.4 StringBuilder"></a>4.4 StringBuilder</h3><p>方法都一样比前者快，但线程不安全，单线程最好用这个。</p>
<p><strong>对比：</strong></p>
<ol>
<li>String：不可变序列，效率低但是复用率高</li>
<li>StringBuilder：可变字符序列，效率最高但线程不安全</li>
<li>StringBuffer：可变，效率较高，线程安全</li>
</ol>
<h3 id="4-5-Math"><a href="#4-5-Math" class="headerlink" title="4.5 Math"></a>4.5 Math</h3><p><strong>常用方法：</strong><br><code>abs</code> <code>pow</code> <code>ceil</code> <code>floor</code> <code>round</code> <code>sqrt</code> <code>max</code> <code>min</code></p>
<h3 id="4-6-Arrays"><a href="#4-6-Arrays" class="headerlink" title="4.6 Arrays"></a>4.6 Arrays</h3><p><strong>常用方法：</strong><br><code>toString</code> <code>sort</code> <code>binarySearch</code> <code>copyOf</code> <code>fill</code><br><code>equals</code>：比较两个数组元素内容是否完全一样<br> <code>asList</code>：将一组值转为<code>list</code></p>
<h3 id="4-7-System类"><a href="#4-7-System类" class="headerlink" title="4.7 System类"></a>4.7 System类</h3><p><strong>常用方法：</strong><br><code>exit</code> <code>currentTimeMillens</code> <code>gc</code> <code>arraycopy</code></p>
<h3 id="4-8-BigInteger-和-BigDecimal"><a href="#4-8-BigInteger-和-BigDecimal" class="headerlink" title="4.8 BigInteger 和 BigDecimal"></a>4.8 BigInteger 和 BigDecimal</h3><p><code>add</code> <code>subtract</code> <code>multiply</code> <code>divide</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">bc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9.9999999999999&quot;</span>);</span><br><span class="line"><span class="comment">//如果小数除不尽会抛出异常，此时需要指定精度</span></span><br><span class="line">sout(bc1.divide(bc2,BigDecimal.ROUND_CEILING));</span><br></pre></td></tr></table></figure>

<h3 id="4-9-日期类"><a href="#4-9-日期类" class="headerlink" title="4.9 日期类"></a>4.9 日期类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一代日期类</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取=当前系统时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">9234567</span>);</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>..(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(d1);</span><br><span class="line"><span class="comment">//第二代日期类</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//创建对象</span></span><br><span class="line">sout(<span class="string">&quot;年:&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line"><span class="comment">//返回月时是从零开始编号的</span></span><br><span class="line">sout(<span class="string">&quot;月:&quot;</span> + c.get((Calendar.MONTH)+<span class="number">1</span>));</span><br><span class="line"><span class="comment">//等等 没有专门的格式化方法 程序员自己组合显示</span></span><br><span class="line"><span class="comment">//第三代日期类(JDK8)</span></span><br><span class="line"><span class="comment">//LocalDate//年月日 LocalTime() //时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//都有</span></span><br><span class="line">ldt.getYear();</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> D..ofPattern(<span class="string">&quot;yyyy-MM-dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dtf.format(ldt);</span><br></pre></td></tr></table></figure>

<h2 id="5-集合"><a href="#5-集合" class="headerlink" title="5. 集合"></a>5. 集合</h2><h3 id="5-1-集合体系图"><a href="#5-1-集合体系图" class="headerlink" title="5.1 集合体系图"></a>5.1 集合体系图</h3><p><img src="C:/Users/吴亦涵/AppData/Roaming/Typora/typora-user-images/image-20240327121024092.png" alt="image-20240327121024092"></p>
<p><img src="C:/Users/吴亦涵/AppData/Roaming/Typora/typora-user-images/image-20240327121238273.png" alt="image-20240327121238273"></p>
<p><strong>开发中的集合选型：</strong></p>
<ol>
<li>先判断存储类型（一组数据or一组键值对）</li>
<li>一组对象：Collection接口<ul>
<li>允许重复：List<ul>
<li>增删多：LinkedList（底层维护了双向链表）</li>
<li>改查多：ArrayList（Object类型可变数组）</li>
</ul>
</li>
<li>不允许重复：Set<ul>
<li>无序：HashSet（底层HashMap 维护了哈希表（数组+链表+红黑树））</li>
<li>排序：TreeSet</li>
<li>插入取出顺序一致：LinkedList（维护了数组+双向链表）</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对：Map<ul>
<li>键无序：HashMap（底层哈希表）</li>
<li>键排序：TreeMap</li>
<li>插入取出顺序一致：LinkedHashMap</li>
<li>读取文件：Properties</li>
</ul>
</li>
</ol>
<h3 id="5-2-Collection接口"><a href="#5-2-Collection接口" class="headerlink" title="5.2 Collection接口"></a>5.2 Collection接口</h3><p><strong>概述与常用方法</strong></p>
<ol>
<li><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</code><br>Collection没有直接的实现子类，通过子接口<code>Set</code>和<code>List</code>实现。</li>
<li><code>add</code> <code>remove</code> <code>contains</code> <code>size</code> <code>isEmpty</code> <code>clear</code> <code>addAll</code> <code>containsAll</code> <code>removeAll</code></li>
</ol>
<p><strong>遍历方式：</strong></p>
<p><strong>Iterator迭代器遍历：</strong></p>
<ol>
<li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。<br>所有实现了<code>Collection</code>接口的集合类都有一个<code>iterator()</code>方法，用以返回一个实现了Iterator接口的对象（返回一个迭代器）Iterator仅用于遍历集合，本身并不存放对象。</li>
<li>方法：<code>next()</code> <code>hasNext()</code> <code>remove</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection col=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">Iterator iterator=col.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Object obj=iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;<span class="comment">//再次遍历需要重置迭代器 因为内部指针已经到末尾了</span></span><br><span class="line">iterator = col.iterator();</span><br></pre></td></tr></table></figure>

<p><strong>增强for循环：</strong><br>本质就是简化版的iterator迭代器，只能用于遍历集合或数组。当这段代码被编译时，编译器会将其转换为迭代器对应的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection col=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">for</span>(Object book : col)&#123;</span><br><span class="line">    sout(book);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-List接口"><a href="#5-3-List接口" class="headerlink" title="5.3 List接口"></a>5.3 List接口</h3><p>元素有序且可重复，支持对应的顺序索引</p>
<p><strong>常用方法：</strong></p>
<ol>
<li><p><code>void add(int index, Object ele)</code>在index处插入元素</p>
</li>
<li><p><code>boolean addAll(int index, Collection eles)</code>从index处开始将eles中的所有元素添加进来。</p>
</li>
<li><p><code>Object get(int index)</code>获取指定索引元素<br><code>Object remove(int index)</code>删除</p>
</li>
<li><p><code>int indexOf(Object obj) </code> 首次出现<br><code>int lastIndexOf(Object obj)</code>末次出现</p>
</li>
<li><p><code>Object set(int index, Object ele)</code>替换</p>
</li>
<li><p><code>List subList(int fromIndex, int toIndex)</code>返回子集合</p>
</li>
<li><p>List的普通for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    sout(list.get(i));&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>练习：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;AAA&quot;</span>,<span class="string">&quot;aaa&quot;</span>,<span class="number">100</span>));...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size()-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">        Book book1=(Book)list.get(j);<span class="comment">//记得要转型</span></span><br><span class="line">        Book book2=(Book)list.get(j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(book1.getPrice()&gt;book2.getPrice())&#123;</span><br><span class="line">            list.set(j,book2);</span><br><span class="line">            list.set(j+<span class="number">1</span>,book1);</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-1-ArrayList"><a href="#5-3-1-ArrayList" class="headerlink" title="5.3.1 ArrayList"></a>5.3.1 ArrayList</h4><p><strong>细节：</strong></p>
<ol>
<li>可以加入多个<code>null</code></li>
<li>基本由数组来实现</li>
<li>基本等同于<code>Vector</code>，效率更高，但是线程不安全，多线程建议<code>Vector</code></li>
</ol>
<p><strong>源码：</strong></p>
<ol>
<li>里面维护了一个Object类型的数组<code>elementData</code></li>
<li>创建对象时若使用无参构造器，则初始<code>elementData</code>容量为0</li>
<li>添加元素时先判断是否需要扩容，若需要则调用<code>grow</code>方法</li>
<li>若使用无参构造器，若第一次添加需要扩容，则扩容<code>elementData</code>容量为10，再次需要扩容则为1.5倍。</li>
<li>若使用指定容量的构造器，则初始<code>elementData</code>容量为capacity，若再次扩容则直接1.5倍。</li>
</ol>
<h4 id="5-3-2-LinkedList"><a href="#5-3-2-LinkedList" class="headerlink" title="5.3.2 LinkedList"></a>5.3.2 LinkedList</h4><p><strong>细节：</strong></p>
<ol>
<li>底层实现了双向链表和双端队列特点（维护双向链表）</li>
<li>可以添加任意元素，包括null</li>
<li>线程不安全，没有实现同步</li>
</ol>
<p><strong>底层：</strong></p>
<ol>
<li>底层维护了一个双向链表</li>
<li>维护了两个属性first和last分别指向首节点和尾节点</li>
<li>每个节点<code>Node</code>里面又维护了<code>prev</code> <code>next</code> <code>item</code> 三个属性实现双向链表，因此添加删除效率较高</li>
</ol>
<h3 id="5-4-Set接口"><a href="#5-4-Set接口" class="headerlink" title="5.4 Set接口"></a>5.4 Set接口</h3><p><strong>细节：</strong></p>
<ol>
<li>无序且没有索引（存取顺序不一样 但是取出顺序固定）</li>
<li>不允许重复元素，因此最多包含一个null</li>
<li>常用实现类：<code>TreeSet</code> <code>HashSet</code></li>
<li>底层存放的也是键值对，但value用默认常量Object填充</li>
</ol>
<h4 id="5-4-1-HashSet"><a href="#5-4-1-HashSet" class="headerlink" title="5.4.1 HashSet"></a>5.4.1 HashSet</h4><p><strong>底层：</strong></p>
<ol>
<li>底层实际上是<code>HashMap</code>（数组+链表+红黑树）<br>构造器源码：<code>map = new HashMap&lt;&gt;();</code></li>
<li>添加一个元素时，先得到hash值，再转成索引值</li>
<li>找到存储数据表table，看这个索引位置是否已经存放元素，若没有则直接加入，若有则调用equals比较，相同则放弃添加，不同则添加在最后</li>
<li>若一条链表的元素个数超过8并且table大小超过64，就会进行树化</li>
<li>若要自定义属性值相同则对象相同不添加，则重写<code>equals</code>与<code>hashcode</code></li>
</ol>
<h4 id="5-4-2-LinkedHashSet"><a href="#5-4-2-LinkedHashSet" class="headerlink" title="5.4.2 LinkedHashSet"></a>5.4.2 LinkedHashSet</h4><ol>
<li>是HashSet的子类，但是插入与取出顺序一致</li>
<li>底层是LinkedHashMap，维护了一个数组+双向链表</li>
<li>hashCode决定存储位置，不允许添加重复元素</li>
</ol>
<p><strong>底层：</strong></p>
<ol>
<li>维护了一个hash表和双向链表（有head和tail）</li>
<li>每个节点有before和after属性，形成双链表</li>
<li>添加元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入双向链表。</li>
</ol>
<h4 id="5-4-3-TreeSet"><a href="#5-4-3-TreeSet" class="headerlink" title="5.4.3 TreeSet"></a>5.4.3 TreeSet</h4><p>初步添加元素时仍然无序，可以创建时就通过构造器进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o1.compareTo((String) o2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-5-Map接口"><a href="#5-5-Map接口" class="headerlink" title="5.5 Map接口"></a>5.5 Map接口</h3><p><strong>细节：</strong></p>
<ol>
<li>常用实现类：<code>HashMap</code> <code>HashTable</code> <code>Properties</code></li>
<li>Map与Collection无关系，用于保存具有映射关系的数据<code>Key-Value</code>（双列元素）常用String类作为<code>key</code></li>
<li><code>key</code>不允许重复且只能有一个null，<code>value</code>可以多个，当有相同的<code>key</code>就等价于替换</li>
<li>一对k-v是放在一个<code>Node</code>中的，因为有<code>Node</code>实现了Entry接口，因此一对k-v就是一个Entry（实际存放位置是Map的<code>Node</code>内部类，但是实现了Entry的接口，所以向上转型将引用存在EntrySet里方便遍历，且ES提供两个重要方法为<code>getKey()</code> <code>getValue()</code>）<br><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</code></li>
</ol>
<p><strong>方法：</strong><code>put</code> <code>remove</code> <code>get</code> <code>size</code> <code>isEmpty</code> <code>clear</code> <code>containsKey</code> <code>keySet</code> <code>entrySet</code> <code>values</code></p>
<p><strong>遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种:先取出所有key 再根据kay取出value</span></span><br><span class="line">Set&lt;String&gt; set=map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">    System.out.println(s+<span class="string">&quot;=&quot;</span>+map.get(s));</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;String&gt; iterator= set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    String s=iterator.next();<span class="comment">//注意指针易错点</span></span><br><span class="line">    System.out.println(s+<span class="string">&quot;=&quot;</span>+map.get(s));</span><br><span class="line">&#125;<span class="comment">//第二种直接Collection取出所有value...</span></span><br><span class="line"><span class="comment">//第三种方式:直接取出一对</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set=map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : set) &#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator= set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; entry=iterator.next();</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-HashMap"><a href="#5-5-1-HashMap" class="headerlink" title="5.5.1 HashMap"></a>5.5.1 HashMap</h4><ol>
<li>没有实现同步，线程不安全</li>
<li>底层机制略 . . .</li>
</ol>
<h4 id="5-5-2-HashTable"><a href="#5-5-2-HashTable" class="headerlink" title="5.5.2 HashTable"></a>5.5.2 HashTable</h4><ol>
<li>key和value都不能为null，否则抛出异常</li>
<li>线程安全</li>
</ol>
<h4 id="5-5-3-Properties"><a href="#5-5-3-Properties" class="headerlink" title="5.5.3 Properties"></a>5.5.3 Properties</h4><ol>
<li>继承自HashTable并且实现了Map接口，也是键值对</li>
<li>可以用于从<code>xxx.properties</code>文件中加载数据到<code>Properties</code>类对象，并进行读取和修改（此文件通常为配置文件）</li>
</ol>
<h4 id="5-5-4-TreeMap"><a href="#5-5-4-TreeMap" class="headerlink" title="5.5.4 TreeMap"></a>5.5.4 TreeMap</h4><p>初始化时可排序。</p>
<h3 id="5-6-Collections工具类"><a href="#5-6-Collections工具类" class="headerlink" title="5.6 Collections工具类"></a>5.6 Collections工具类</h3><ol>
<li>是一个操作List、Set、Map等集合的工具类，提供了一系列静态方法对集合元素进行排序、查询、修改等操作</li>
<li>方法：<code>reverse</code> <code>shuffle</code> <code>sort</code> <code>swap(list, int i, int j)</code> <code>max</code> <code>min</code> <code>frequency</code> <code>copy</code> <code>replaceAll</code></li>
</ol>
<h2 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h2><p><strong>作用：</strong><br>泛型又称参数化类型，解决数据类型的安全性问题。<br>编译时，检查元素的类型，提高了安全性（避免不小心放错导致运行错误）且减少了类型转换的次数，提高效率。</p>
<p><strong>细节：</strong></p>
<ol>
<li><code>interface List&lt;T&gt;&#123;&#125; public class HashSet&lt;E&gt;&#123;&#125;</code><br>其中T和E是标识符只能传引用数据类型 不写默认Object类型</li>
<li>在指定泛型具体类型后，可以传入子类型</li>
</ol>
<p><strong>自定义泛型类：</strong></p>
<ol>
<li>普通成员可以使用泛型</li>
<li>使用泛型的数组不能初始化（不确定类型就无法new空间）</li>
<li>静态方法中不能使用类的泛型（类加载时对象尚未创建）</li>
<li>泛型类的类型在创建对象时确定，若无指定类型默认Object</li>
</ol>
<p><strong>自定义泛型接口：</strong></p>
<ol>
<li>泛型接口的类型在<strong>继承接口</strong>或实现接口时确定</li>
<li>没显式声明则默认Object</li>
</ol>
<p><strong>自定义泛型方法：</strong><br>修饰符 &lt;T, R&gt; 返回类型 方法名（形参列表）{ }</p>
<ol>
<li>泛型方法可定义在普通类中，也可定义在泛型类中<br>可以使用类声明的泛型，也可以使用自己声明的泛型</li>
<li>泛型方法被调用时，类型会确定</li>
<li>注意<code>public void eat(E e)&#123;&#125;</code>修饰符后没有&lt;T，R&gt;所以不是泛型方法，只是使用了泛型。</li>
</ol>
<p><strong>泛型的继承与通配符：</strong></p>
<ol>
<li>泛型不具备继承性</li>
<li><?>支持任意泛型类型</li>
<li><? extends A>支持A类及A的子类，规定了泛型上限</li>
<li><? super A>支持A类及A的父类，不限于直接父类，规定了泛型下限</li>
</ol>
<p> <strong>JUnit单元测试：</strong>很好的东西。@Test即可使用</p>
<h2 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7. 多线程"></a>7. 多线程</h2><h3 id="7-1-基础概念"><a href="#7-1-基础概念" class="headerlink" title="7.1 基础概念"></a>7.1 基础概念</h3><p><strong>进程：</strong></p>
<ol>
<li>运行中的程序。启用程序，操作系统就会为该进程分配内存空间，启动了一个进程。</li>
<li>进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程：有自身的产生、存在、消亡过程。</li>
</ol>
<p><strong>线程：</strong></p>
<ol>
<li>由进程创建的，是进程的一个实体</li>
<li>一个进程可以拥有多个线程</li>
<li>单线程 、 多线程</li>
<li>并发：同一时刻，多个任务交替执行（造成貌似同时的错觉）单核cpu实现的多任务就是并发</li>
<li>并行：同一时刻多个任务同时执行。多核cpu可实现并行</li>
</ol>
<h3 id="7-2-线程基本机制"><a href="#7-2-线程基本机制" class="headerlink" title="7.2 线程基本机制"></a>7.2 线程基本机制</h3><p><strong>创建线程两种方式：</strong></p>
<ol>
<li><p>继承Tread类，重写run方法</p>
</li>
<li><p>实现Runnable接口，重写run方法<br>因为当某个类继承了父类之后，单继承机制使得此类再继承Thread方法已经不行了，于是就可以去实现接口</p>
<p><img src="C:/Users/吴亦涵/AppData/Roaming/Typora/typora-user-images/image-20240329091443572.png" alt="image-20240329091443572"></p>
</li>
<li><p><code>JConsole</code>监视管理线程</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cat cat=<span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//创建cat对象当线程使用</span></span><br><span class="line">        cat.start();<span class="comment">//启动线程</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> times=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cat &quot;</span>+(++times));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>真正实现多线程的是<code>start()</code>中的<code>start0()</code>方法，<code>run()</code>只是一个普通的方法</li>
<li>当main启动一个子线程Thread-0，主线程不会阻塞</li>
<li><code>start()</code>方法调用<code>start0()</code>方法之后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行取决于CPU，由CPU统一调度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式 当子类继承其它父类的时候只能实现接口</span></span><br><span class="line">Dog dog=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(dog);<span class="comment">//静态代理</span></span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//静态代理模式的简单模拟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//类型是Runnable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span><span class="params">(Runnable target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target != <span class="literal">null</span>)</span><br><span class="line">            target.run();<span class="comment">//动态绑定 运行类型Dog</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;start0();&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>&#123;run();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口更适合多个线程共享一个资源的情况 且避免了单继承的限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多线程问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Ticket ticket= <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">//多个线程共享一个对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket).start();&#125;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">100</span>;<span class="comment">//资源共享</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">//这里造成超卖</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口 &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;卖票 还剩余 &quot;</span>+(--count)+<span class="string">&quot; 张票&quot;</span>);&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-线程终止"><a href="#7-3-线程终止" class="headerlink" title="7.3 线程终止"></a>7.3 线程终止</h3><p>类里设置一个控制变量放入循环，并提供set方法，就可以在主线程里通知子线程结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ticket ticket= <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ticket).start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">ticket.setLoop(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-4-常用方法"><a href="#7-4-常用方法" class="headerlink" title="7.4 常用方法"></a>7.4 常用方法</h3><ol>
<li><code>setName</code>设置线程名称，使其与参数name相同</li>
<li><code>getname</code>返回线程名称</li>
<li><code>start</code>使线程开始执行（JVM调用<code>start0</code>）<br>它底层会创建新的线程并调用<code>run</code></li>
<li><code>run</code>调用线程run方法</li>
<li><code>setPriority</code>更改线程优先级</li>
<li><code>getPriority</code>获取线程优先级</li>
<li><code>sleep</code>让线程休眠 线程中的静态方法</li>
<li><code>interrupt</code>中断线程（并非终止）<br>一般用于中断正在休眠线程</li>
</ol>
<h4 id="7-4-1-线程中断"><a href="#7-4-1-线程中断" class="headerlink" title="7.4.1 线程中断"></a>7.4.1 线程中断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eat</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(eat);</span><br><span class="line">        thread.setName(<span class="string">&quot;555吃包子&quot;</span>);</span><br><span class="line">        thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;hi &quot;</span> + i);&#125;</span><br><span class="line">        thread.interrupt();&#125;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eat</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 吃包子 &quot;</span> + i);&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 休眠中~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//该线程执行到一个interrupt时就会catch一个异常 可加入业务代码</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断了~&quot;</span>);&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-2-线程礼让与插队"><a href="#7-4-2-线程礼让与插队" class="headerlink" title="7.4.2 线程礼让与插队"></a>7.4.2 线程礼让与插队</h4><p><strong>线程礼让：</strong><code>yield</code>让出cpu让其它线程执行，但是礼让的时间不确定，所以也不一定礼让成功。在资源紧张的时候用处较大。（涉及操作系统底层）</p>
<p><strong>线程插队：</strong><code>join</code>插队的线程一旦插队成功，则肯定先执行完插入线程的所有任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; hi&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>)<span class="comment">//main执行五次之后就礼让thread</span></span><br><span class="line">        thread.join();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-3-守护线程"><a href="#7-4-3-守护线程" class="headerlink" title="7.4.3 守护线程"></a>7.4.3 守护线程</h4><ol>
<li>用户线程：也叫工作线程，当线程的任务执行完毕或通知方式结束</li>
<li>守护线程：一般是为了工程线程服务，当所有的用户线程结束，守护线程自动结束（垃圾回收机制）<code>thread.setDaemon(true);</code></li>
</ol>
<h4 id="7-4-4-线程的七大状态"><a href="#7-4-4-线程的七大状态" class="headerlink" title="7.4.4 线程的七大状态"></a>7.4.4 线程的七大状态</h4><p><img src="C:/Users/吴亦涵/AppData/Roaming/Typora/typora-user-images/image-20240401123231589.png" alt="image-20240401123231589"></p>
<p>其中<code>Runnable</code>状态可分为<code>Ready</code> 与<code>Running</code>，具体能否执行由内核决定</p>
<h4 id="7-4-5-线程同步机制"><a href="#7-4-5-线程同步机制" class="headerlink" title="7.4.5 线程同步机制"></a>7.4.5 线程同步机制</h4><p><strong>同步代码块：</strong><code>synchronized(对象) &#123; &#125;</code><br>还可以放在方法声明中，表示整个方法为同步方法：<code>public synchronized void f</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;<span class="comment">//同步方法 但锁在this上</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//错误,这样就只有一个窗口卖完</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;卖票 还剩余 &quot;</span> + (--count) + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">    &#125;&#125;<span class="comment">//要纠正的卖票问题应该是卖一张票时的判断与卖的行为</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;sell();&#125;</span><br><span class="line"><span class="comment">//正确实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> loop=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            loop=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;卖票 还剩余 &quot;</span> + (--count) + <span class="string">&quot; 张票&quot;</span>);&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="keyword">while</span> (loop) &#123;sell();&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>互斥锁：</strong></p>
<ol>
<li><p>锁可在类、对象、方法上，保证<strong>共享数据</strong>操作的完整性</p>
</li>
<li><p>每个对象都对应于一个可称为“互斥锁”的标记，此标记用来保证在任一时刻只能有一个线程访问该对象</p>
</li>
<li><p>关键字<code>synchronized</code>来与对象的互斥锁联系，当某个对象用此修饰时，表明该对象在任一时刻只能由一个线程访问</p>
</li>
<li><p>同步的局限性：导致程序的执行效率较低</p>
</li>
<li><p>同步方法（非静态）的锁可以是this，也可是其他对象（同一对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法（静态的）的锁为当前类本身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;&#125;<span class="comment">//锁在类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(thread.class)&#123;sout(<span class="string">&quot;haha&quot;</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量选择同步代码块 范围越小效率越高</p>
</li>
</ol>
<p><strong>死锁：</strong>多个线程都占用了对方的锁资源，但互不相让导致了死锁，所以不要在一个方法里搞两个锁</p>
<p><strong>释放锁分析：</strong></p>
<ol>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步方法、同步代码块遇到break、return</li>
<li>当前线程在同步方法、同步代码块中出现了未处理的Error或Exception导致异常结束</li>
<li>当前线程在同步方法、同步代码块执行了线程对象的wait()方法，当前线程暂停，释放锁</li>
<li>线程中断sleep()、yield()只会暂停当前线程的执行，不会释放锁</li>
</ol>
<h4 id="7-4-6-课堂练习"><a href="#7-4-6-课堂练习" class="headerlink" title="7.4.6 课堂练习"></a>7.4.6 课堂练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在main方法中启动两个线程,1线程循环打印100以内的整数,直到2线程从键盘读取了“Q”的命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        B b=<span class="keyword">new</span> <span class="title class_">B</span>(a);<span class="comment">//b线程需要持有a线程对象才能进行通知</span></span><br><span class="line">        Thread thread2=<span class="keyword">new</span> <span class="title class_">Thread</span>(b);</span><br><span class="line">        Thread thread1=<span class="keyword">new</span> <span class="title class_">Thread</span>(a);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();&#125;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> loop=<span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println((<span class="type">int</span>)(Math.random()*<span class="number">100</span>+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);&#125;&#125;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.loop=loop;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;<span class="built_in">this</span>.a=a;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(scanner.next().equals(<span class="string">&quot;Q&quot;</span>))&#123;</span><br><span class="line">                a.setLoop(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-IO流"><a href="#8-IO流" class="headerlink" title="8. IO流"></a>8. IO流</h2><h3 id="8-1-文件"><a href="#8-1-文件" class="headerlink" title="8.1 文件"></a>8.1 文件</h3><p>文件在程序中以流的形式来操作。<br><code>File</code>实现了<code>Serializable</code>及<code>Comparable</code>接口<br>输入流：数据从数据源（文件）到程序（内存）的路径<br>输入流：数据从程序（内存）到数据源（文件）的路径</p>
<p><strong>常用操作：</strong></p>
<ol>
<li><p>创建文件对象相关构造器以及方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 直接输入地址创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;BasicCodes\\src\\a.txt&quot;</span>);</span><br><span class="line">file.createNewFile();<span class="comment">//需要抛出IOException或try catch</span></span><br><span class="line"><span class="comment">//方法二 父文件路径加子文件名</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, <span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文件相关信息<br><code>getName</code> <code>getAbsolutePath</code> <code>getParent</code> <code>length</code> <code>exists</code> <code>isFile</code> <code>isDirectory</code></p>
</li>
<li><p>目录操作及文件删除<br><code>mkdir</code> -创建一级目录<code>mkdirs</code>-创建多级目录（一般用此） <code>delete</code></p>
</li>
</ol>
<h3 id="8-2-流的分类"><a href="#8-2-流的分类" class="headerlink" title="8.2 流的分类"></a>8.2 流的分类</h3><p>按照<strong>操作数据单位</strong>不同分为：字节流（8 bits 适合二进制文件）字符流（按字符 文本文件效率更高）</p>
<p>按照<strong>数据流的流向</strong>不同分为：输入流、输出流</p>
<p>按照<strong>角色</strong>不同分为：节点流、处理流 &#x2F; 包装流</p>
<table>
<thead>
<tr>
<th align="center"><mark>抽象</mark>基类</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>输入流</strong></td>
<td align="center">InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td align="center"><strong>输出流</strong></td>
<td align="center">OutputStream</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<h4 id="8-2-1-字节流"><a href="#8-2-1-字节流" class="headerlink" title="8.2.1 字节流"></a>8.2.1 字节流</h4><p><strong>InputStream&#x2F;OnputStream的常用子类：</strong>（并非都是直接子类）</p>
<ol>
<li><p>FileInputStream 文件输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;BasicCodes\\src\\a.txt&quot;</span>);</span><br><span class="line">FileInputStream fileInputStream=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line"><span class="type">int</span> read=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((read = fileInputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>)read);&#125;<span class="comment">//记得转成char</span></span><br><span class="line">fileInputStream.close();</span><br><span class="line"><span class="comment">//若文件里有中文，则会输出乱码，因为汉字包含三个字节</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高效率的重载方法-read(byte[] byte)</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//读取的有效长度</span></span><br><span class="line"><span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));&#125;</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure>

<p>FileOutputStream 文件输出流（若文件不存在会直接创建文件 前提是目录已存在）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法会覆盖原来的数据</span></span><br><span class="line">FileOutputStream fileOutputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file1);</span><br><span class="line">String s=<span class="string">&quot;hellllllllllo!!!&quot;</span>;</span><br><span class="line">fileOutputStream.write(s.getBytes(),<span class="number">0</span>,s.length());</span><br><span class="line">fileOutputStream.close();</span><br><span class="line"><span class="comment">//将append参数设为true则可以追加</span></span><br><span class="line">FileOutputStream fileOutputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file1, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>练习：文件的拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;BasicCodes\\src\\a.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;BasicCodes\\src\\b.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line">    <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(bytes,<span class="number">0</span>,len);&#125;</span><br><span class="line">    fis.close(); fos.close();&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>BufferedInputStream 缓冲字节输入流</p>
</li>
<li><p>ObjectInputStream 对象字节输入流</p>
</li>
</ol>
<h4 id="8-2-1-字节流-1"><a href="#8-2-1-字节流-1" class="headerlink" title="8.2.1 字节流"></a>8.2.1 字节流</h4><p><strong>常用方法：</strong></p>
<ol>
<li><code>read()</code>每次读取单个字符，到末尾则返回-1</li>
<li><code>read(char[])</code>批量读取多个字符到数组 返回读到的字符数 到末尾返回-1</li>
<li><code>write(int)</code> <code> write(char[])</code> <code>write(char[], off, len)</code> <code>write(string)</code> <code>write(string, off, len)</code></li>
</ol>
<p><strong>练习一复制文件：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(file1);</span><br><span class="line">FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2);</span><br><span class="line"><span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(ch)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    fw.write(ch,<span class="number">0</span>,len);&#125;</span><br><span class="line">fr.close(); fw.close();</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-节点流和处理流"><a href="#8-2-3-节点流和处理流" class="headerlink" title="8.2.3 节点流和处理流"></a>8.2.3 节点流和处理流</h4><p><strong>节点流</strong>可以从一个特定的数据源读写数据 例如FileReader</p>
<p><strong>处理流</strong>（包装流）是”连接“在已存在流之上，为程序提供更强大读写功能，也更加灵活，如BufferedReader<br>举例：BufferedReader类中，有属性Reader，可以封装任意一个节点流（只要是Reader子类就行）</p>
<p><strong>区别与联系：</strong></p>
<ol>
<li><p>节点流是底层流（低级流）直接跟数据源相接</p>
</li>
<li><p>处理流包装节点流，既可以消除不同节点流之间的实现差异，也可以提供更方便的方法来完成输入输出，且提高了性能 主要以增加缓冲的方式来提高输入输出的效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;BasicCodes\\src\\a.txt&quot;</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line=bfr.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);&#125;</span><br><span class="line">bfr.close();<span class="comment">//底层会自动关闭FileReader</span></span><br></pre></td></tr></table></figure></li>
<li><p>处理流的包装使用了<strong>修饰器设计模式</strong>，不会直接与数据源相连<br><strong>修饰器设计模式</strong>：主要用于向一个现有的对象添加新的功能，而不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持原类方法签名完整性的前提下，提供了额外的功能。通常通过创建一个包含有基本对象的成员变量的新类实现，这个类在构造器中接收被装饰的对象，新类的方法中调用原对象的方法，然后执行额外的功能。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">bufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">bufferedReader</span>(<span class="keyword">new</span> <span class="title class_">fileReader</span>());</span><br><span class="line">        bfr.readFile(<span class="number">3</span>);&#125;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fileReader</span> <span class="keyword">extends</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取文件...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stringReader</span> <span class="keyword">extends</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取字符串...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bufferedReader</span> <span class="keyword">extends</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> reader rd;</span><br><span class="line">    <span class="comment">//接受reader的子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">bufferedReader</span><span class="params">(reader rd)</span> &#123;<span class="built_in">this</span>.rd = rd;&#125;</span><br><span class="line">    <span class="comment">//多次读取文件(拓展readFile 让方法更加灵活)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            rd.readFile();&#125;</span><br><span class="line">    &#125;<span class="comment">//还可以加缓冲等等</span></span><br><span class="line">    <span class="comment">//批量处理字符串数据(拓展readString)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            rd.readString();&#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="comment">//优化版-动态绑定机制</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fileReader</span> <span class="keyword">extends</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;读取文件...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stringReader</span> <span class="keyword">extends</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;读取字符串...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bufferedReader</span> <span class="keyword">extends</span> <span class="title class_">reader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> reader rd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">bufferedReader</span><span class="params">(reader rd)</span> &#123;<span class="built_in">this</span>.rd = rd;&#125;</span><br><span class="line">    <span class="comment">//多次读取文件(拓展readFile 让方法更加灵活)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;rd.read();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;rd.read();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-对象流"><a href="#8-2-4-对象流" class="headerlink" title="8.2.4 对象流"></a>8.2.4 对象流</h4><p><strong>需求场景：</strong>能够对 基本数据类型 或 对象 进行序列化和反序列化操作，例如：将<code>int num = 100</code>这个int数据保存到文件中，取出时从文件直接恢复成int 100<br><strong>序列化：</strong>保存数据时，保存它的值和数据类型<br><strong>反序列化：</strong>恢复数据时，恢复它的值和数据类型<br>需要让某个对象支持序列化机制，则必须让其类是可序列化的，而此类必须实现两个接口之一：<code>Serializable</code> (标记接口声明性质，里面没有任何方法)  或者<code>Externalizable</code> (要实现方法 所以一般不选)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>))</span><br><span class="line"><span class="comment">//注意此处有自己的储存格式 不会是txt</span></span><br><span class="line">oos.writeInt(<span class="number">100</span>);<span class="comment">//包装成Integer实现了Serializable</span></span><br><span class="line">oos.writeUTF(<span class="string">&quot;wawa&quot;</span>);<span class="comment">//注意字符串是UTF 其余同上</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;yeye&quot;</span>, <span class="number">3</span>));<span class="comment">//序列化对象</span></span><br><span class="line">oos.close();</span><br><span class="line"><span class="comment">//反序列化(顺序一定要和序列化时一样 不然出错)</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>));</span><br><span class="line">sout(ois.readInt());</span><br><span class="line">sout(ois.readUTF());</span><br><span class="line">sout(ois.readObject());<span class="comment">//底层会将Object转化为Dog</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>读写顺序要一致</p>
</li>
<li><p>要实现接口<code>Serializable</code></p>
</li>
<li><p>序列化的类中建议添加SerialVersionUID（版本号），为了提高版本性能（例如增改属性 不会认为是新的类）</p>
</li>
<li><p>除了static或transient修饰的成员，序列化对象时默认将里面所有属性都进行序列化</p>
<p><strong>static成员的特例</strong>：<code>static</code>修饰的成员变量属于类的状态，而不是单个对象的状态。因此，它们不是对象特有的数据，而是属于类本身的。在序列化过程中，Java虚拟机（JVM）不会将static成员变量序列化，因为序列化和反序列化的目标是对象的状态，不包括类的静态状态。</p>
<p><strong>transient成员的特例</strong>：<code>transient</code>关键字用于标记不想通过序列化持久化的成员变量。如果一个属性被标记为<code>transient</code>，那么这个属性将被忽略，不会被序列化。通常这是因为属性可能不需要持久化（例如，可能包含敏感信息），或者其值可以在反序列化后重新计算或重新获取。</p>
</li>
<li><p>序列化对象时，要求里面属性的类型也实现序列化接口</p>
</li>
<li><p>序列化具备可继承性，子类也默认实现了序列化</p>
</li>
</ol>
<h4 id="8-2-5-输入输出"><a href="#8-2-5-输入输出" class="headerlink" title="8.2.5 输入输出"></a>8.2.5 输入输出</h4><p><strong>标准输入：</strong><code>InputStream</code> 默认设备为键盘<br><strong>标准输出：</strong><code>OutputStream</code> 默认设备为显示器</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/05/%E8%87%AA%E5%88%B6%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/" rel="prev" title="自制动态数组">
                  <i class="fa fa-angle-left"></i> 自制动态数组
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/26/%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F/" rel="next" title="">
                   <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81OTU0My8zNjAwNQ=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Antarctica</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
